<?php
/**
 * @file
 * drushsubtree drush command.
 *
 *  You can copy this file to any of the following
 *    1. A .drush folder in your HOME folder.
 *    2. Anywhere in a folder tree below an active module on your site.
 *    3. /usr/share/drush/commands (configurable)
 *    4. In an arbitrary folder specified with the --include option.
 *    5. Drupal's /drush or /sites/all/drush folders.
 */

/**
 * Implements hook_drush_command().
 */
function drushsubtree_drush_command() {
  $items = array();

  $items['drushsubtree-build'] = array(
    'description' => "Wrapper around drush make for (re)building site repos.",
    'arguments' => array(
      'config' => '(Optional) path/to/drushsubtree.config.yml',
    ),
    'options' => array(
      'show-info' => array(
        'description' => 'Print $info array from combined make files. (Helpful for development.)',
      ),
      'show-config' => array(
        'description' => 'Print $config array from mysite.config.inc. (Helpful for development.)',
      ),
      'no-commit' => array(
        'description' => 'Do not commit changes. Note: To skip subtree add, pull, or merge use no-subtree-updates.',
      ),
      'no-subtree-updates' => array(
        'description' => 'Do not commit changes. NOTE: ',
      ),
      'message' => array(
        'description' => 'Message to include at the beginning of any new commits.',
      ),
      'simulate' => array(
        'description' => 'Output commands to be executed for examination, but do not actually execute them.',
      ),
      // @todo
      're-add' => array(
        'description' => '@todo Remove and re-add comma separated list of subtree(s).',
      ),
    ),
    'examples' => array(
      'drush drushsubtree-build' => '',
      'drush subtree-build' => '',
      'drush dsb --show-info' => '',
      'drush dsb --message="Rebuild with example_distro release 7.x-1.5"' => '',
      'drush dsb ./drushsubtree.config.inc --re-add=example1,example2,exampleN' => '',
    ),
    'aliases' => array('subtree-build', 'dsb'),
    // No bootstrap at all.
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH,
  );

  $items['drushsubtree-get-tags'] = array(
    'description' => "Get a list of tagged releases for a subtree project.",
    'arguments' => array(
      'project_name' => '',
      'config' => '(Optional) path/to/drushsubtree.config.yml',
    ),
    'examples' => array(
      'drush drushsubtree-get-tags my_project' => '',
    ),
    // No bootstrap at all.
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH,
  );

  $items['drushsubtree-checkout'] = array(
    'description' => '',
    'arguments' => array(),
    'examples' => array(),
    // No bootstrap at all.
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH,
  );

  $items['drushsubtree-pull'] = array(
    'description' => '',
    'arguments' => array(),
    'examples' => array(),
    // No bootstrap at all.
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH,
  );

  $items['drushsubtree-push'] = array(
    'description' => '',
    'arguments' => array(),
    'examples' => array(),
    // No bootstrap at all.
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH,
  );

  $items['drushsubtree-add'] = array(
    'description' => '',
    'arguments' => array(),
    'examples' => array(),
    // No bootstrap at all.
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH,
  );

  $items['drushsubtree-setup-repo'] = array(
    // TODO
    // Prompt:
    // - Create symlink-these directory
    // - Create/Symlink sites directory/-ies.
    // - Create/Symlink .htaccess
    // - Create/Symlink robots.txt
    // - Create mysite.config.inc
    // - Symlink build/make files
    // If site is an instance of a distro with tests:
    // - Symlink behat/travis/etc files generated by cpliakas's drupal-distro
    // - Create testsite.config.inc (if used in build.xml)
  );

  return $items;
}

/**
 * Implements hook_drush_help().
 */
function site_make_drush_help($section) {
  switch ($section) {
    case 'drush:site-make':
      return dt("@todo");

  }
}

/**
 * Implements hook_drush_command().
 */
function drush_drushsubtree_get_tags($subtree_name, $config_file = '') {
  // Get config_file.
  if (!$config_file) {
    $config_file = drushsubtree_get_config_file();
  }
  $config = _drushsubtree_get_config($config_file);
  if (!$details = $config['subtrees'][$subtree_name]) {
    drush_set_error(dt('No subtree config available for !subtree in !config_file'),
      array('!subtree' => $subtree_name, '!config_file' => $config_file));
  }

  // Look up tags from remote specified in $details.
  $tags = drushsubtree_list_remote_tags($subtree_name, $details);

  foreach ($tags as $tag => $id) {
    drush_print("{$tag}\t{$id}");
  }
}

/**
 * Implements drush_hook_COMMAND_validate().
 */
function drush_drushsubtree_build_validate() {
  $is_valid = TRUE;

  // TODO Check drush version. Currently, this requires master branch with
  // --no-recurse option.
  // TODO Check ownership. If ant rebuilds, ownership may be funny.
  // TODO This command must be run from top-level of git repo.
  // TODO Confirm we're in a git repo. cd "$(git rev-parse --show-toplevel)"
  // TODO Confirm config points to a make file.
  // TODO Check code base for make files. See if they're all being included in
  // build. If not, notify user. Ask if we should proceed or not.
  // Helper stuff.
  // TODO Check for subtrees. Give user message if not using.
  // TODO Check for commands to shell_exec. Give user message if not using.
  // Confirm we have a config file.

  return $is_valid;
}

/**
 * Callback for drushsubtree command.
 *
 * @param string $config_file
 *   path/to/config/file providing $config info
 *
 * @see drush_invoke()
 * @see drush.api.php
 */
function drush_drushsubtree_build($config_file = '') {
  // Build up array of commands to be executed in order.
  $commands = array();

  // Get config file.
  if (!$config_file) {
    $config_file = drushsubtree_get_config_file();
  }
  drush_log(dt('Loading configuration from: !config_file', array('!config_file' => $config_file)), 'ok');
  $config = _drushsubtree_get_config($config_file);

  // Assemble $info array by loading, parsing and merging make file(s).
  $build_file = $config['build_file'];
  drush_log(dt('Using build file: !build_file', array('!build_file' => $build_file)), 'ok');
  $info = _drushsubtree_get_info($build_file);

  // If requested, output full build info.
  if (drush_get_option('show-info')) {
    drush_print('$info:');
    drush_print_r($info);
  }

  // Add/update git subtrees.
  // @todo Check if there are uncommitted changes locally. Exit if there are.
  // Otherwise, subtree add/pull won't work.
  // If there are subtrees in the config file, get commands for adding/updating
  // subtrees.
  if (isset($config['subtrees'])) {

    drush_log(dt('Preparing to add/update git subtrees specified here: !config_file', array('!config_file' => $config_file)), 'ok');

    // Prep projects directory. All subtrees will use --prefix=projects/$name
    _drushsubtree_prep_projects_directory();

    // Hang onto symlink commands here. Add these to the $commands array after
    // drush make.
    $symlink_commands = array();

    foreach ($config['subtrees'] as $subtree_name => $details) {
      // Get project info from make file.
      $project_info = (isset($info['projects'][$subtree_name])) ? $info['projects'][$subtree_name] : array();
      // Get subtree commands.
      $subtree_commands = array();
      if (!drush_get_option('no-subtree-updates', FALSE)) {
        $subtree_commands = _drushsubtree_get_subtree_commands($subtree_name, $details, $project_info);
      }
      else {
        drush_log(dt('Skipping git subtree updates.'), 'ok');
      }
      // Remove files checked out by drush. Add symlink pointing to your local
      // subtree.
      drush_log(dt('Preparing to symlink !subtree_name to path: !path', array('!subtree_name' => $subtree_name, '!path' => $details['path'])), 'ok');
      $symlink_commands[] = _drushsubtree_subtree_add_symlink($subtree_name, $details['path']);
      // Add subtree commands to the beginning of the $commands array, to be
      // executed before drush make.
      $commands = array_merge($commands, $subtree_commands);
    }

  }

  // Execute subtree commands now. This way, drush make will include info
  // from make files updated with git subtree pulls.
  foreach ($commands as $command) {
    // @todo Add error handling.
    drush_shell_exec($command);
  }
  // Zero out $commands. Build up next array of commands to be executed.
  $commands = array();

  // Drush make.
  // If target director already exists, remove it.
  $target = $config['target'];
  if (file_exists($target)) {
    $commands[] = "rm -rf $target";
  }
  $commands[] = DRUSH_COMMAND . " make {$build_file} {$target} --no-recursion --no-gitinfofile";

  // Replace downloaded projects with symlinks where subtrees are used.
  $commands = array_merge($commands, $symlink_commands);

  // Custom, site-specific commands defined by config file.
  // Add custom commands from site make config file.
  foreach ($config['commands'] as $command) {
    $commands[] = $command;
  }

  // Commit.
  if (!drush_get_option('no-commit', FALSE)) {
    $message = ($message = drush_get_option('message', FALSE)) ? $message : dt('Rebuild with drush drushsubtree.');
    $commands[] = _drushsubtree_commit($message);
  }

  // Execute commands.
  foreach ($commands as $command) {
    drush_shell_exec($command);
  }

}

/**
 * Load config from config file by calling drushsubtree_config().
 *
 * Helpful tip for developers: You can convert a PHP array to YAML via drush
 * like this. If you know the $config array you want, but you're not sure how to
 * form at it, build the array, then run it through this function:
 *
 *   drush_print(drush_format($config, NULL, 'yaml'));
 *
 * @return array
 *   Return parsed YAML config as PHP array.
 */
function _drushsubtree_get_config($config_file) {
  if (!class_exists('Symfony\Component\Yaml\Parser')) {
    // For Drush PSR-0 and Composer information, see:
    // http://drupal.org/node/1316322.
    drush_log('Autoloading Symfony\Component\Yaml\Parser failed.', 'error');
    return;
  }
  $parser = new Symfony\Component\Yaml\Parser();
  $config = $parser->parse(file_get_contents($config_file));

  // If requested, output loaded config.
  if (drush_get_option('show-config', FALSE)) {
    drush_print('$config:');
    drush_print(drush_format($config, NULL, 'yaml'));
  }

  return $config;
}

/**
 * Parse make/info files.
 *
 * @return array
 *   Assemble $info array by loading, parsing and merging make file(s).
 */
function _drushsubtree_get_info($file) {
  // Load $info from info/make file if it exists.
  if (file_exists($file)) {
    $info = make_parse_info_file($file);
  }
  else {
    return drush_set_error('drushsubtree', dt('Make file does not exist: !here.', array('!here' => $file)));
  }

  // Check for included make files. If they exist, recurse.
  $merge_info = array();
  if (isset($info['includes'])) {
    foreach ($info['includes'] as $include) {
      $more_info = _drushsubtree_get_info($include);
      $merge_info = array_merge_recursive_distinct($merge_info, $more_info);
    }
  }

  $info = array_merge_recursive_distinct($info, $merge_info);

  return $info;
}

/**
 * Provides recursive array merge.
 *
 * For more info see http://danielsmedegaardbuus.dk/
 * 2009-03-19/phps-array_merge_recursive-as-it-should-be
 */
function &array_merge_recursive_distinct(array &$array1, &$array2 = NULL) {
  $merged = $array1;

  if (is_array($array2)) {
    foreach ($array2 as $key => $val) {
      if (is_array($array2[$key])) {
        $merged[$key] = is_array($merged[$key]) ? array_merge_recursive_distinct($merged[$key], $array2[$key]) : $array2[$key];
      }
      else {
        $merged[$key] = $val;
      }
    }
  }

  return $merged;
}

/**
 * Generate git subtree add command to be run from top-level of repo.
 *
 * @param string $directory
 *   Directory name where subtree should live
 *
 * @param array $details
 *   Relevant details for git subtree add command:
 *    - uri
 *    - branch
 *    - squash
 *    - message
 *
 * @return string|bool
 *   Return command to be executed. False for don't do anything.
 */
function _drushsubtree_subtree_add($directory, $details) {
  $prefix = _drushsubtree_get_prefix($directory);

  if (file_exists($prefix)) {
    // Subtree has already been created. Or there's a directory in our way.
    // Skip this step.
    drush_log(dt("This directory already exists: !prefix", $prefix), array('!prefix' => $prefix), 'notice');
    drush_log(dt("Git subtree add command will be skipped. If !prefix is not a subtree, remove this directory and re-run the drushsubtree command.", $prefix), array('!prefix' => $prefix), 'warning');
    // We're done. Return.
    return FALSE;
  }

  // Make sure we have minimum required $details.
  $uri = _drushsubtree_get_uri($details);
  $branch = _drushsubtree_get_branch($details);
  if (!$uri || !$branch) {
    // We're done. Return.
    return FALSE;
  }

  // Squash commit history of subtree into a single commit?
  $squash_history = (isset($details['squash'])) ? $details['squash'] : FALSE;
  $squash = ($squash_history) ? ' --squash' : '';

  // Add custom commit message?
  $message = _drushsubtree_add_subtree_commit_message($details);

  // Build the command to add subtree for the first time.
  $command = "git subtree add --prefix={$prefix} {$squash} {$message} $uri $branch";

  return $command;
}

/**
 * Get message to be included with subtree add/pull/merge commits.
 *
 * Site make config files can specify a message to be included
 * project-by-project.
 *
 * @param array $details
 *   From site make YAML config file.
 *
 * @return string
 *   A commit message flag to a git subtree add, pull, or merge command.
 *   Empty string if no message should be added.
 */
function _drushsubtree_add_subtree_commit_message($details) {
  $drush_message = drush_get_option('message', '');
  $subtree_message = (isset($details['message'])) ? $details['message'] : '';
  if ($drush_message || $subtree_message) {
    $custom_message = ($drush_message) ? "{$drush_message}\n\n\t{$subtree_message}" : $subtree_message;
  }
  $message = ($custom_message) ? " --message='{$custom_message}'" : '';

  return $message;
}

/**
 * Generate git subtree pull command to be run from top-level of repo.
 *
 * @param string $directory
 *   Directory name where subtree should live
 *
 * @param array $details
 *   Relevant details for git subtree pull command from config file:
 *    - uri
 *    - branch
 *    - squash
 *    - message
 *    - pull, bool
 *    - merge, bool
 *
 * @return string|bool
 *   Return command to be executed. False for don't do anything.
 */
function _drushsubtree_subtree_pull($directory, $details) {
  // Check to see if pulls are disabled (e.g. for local development).
  if (isset($details['pull']) && $details['pull'] == FALSE) {
    drush_log(dt('git subtree pull is disabled for !project', array('!project' => $directory)), 'ok');
    return '';
  }

  drush_log(dt('Preparing to pull subtree: !subtree_name', array('!subtree_name' => $directory)), 'ok');

  // Get params for git subtree pull command.
  $prefix = _drushsubtree_get_prefix($directory);
  $uri = _drushsubtree_get_uri($details);
  $branch = _drushsubtree_get_branch($details);
  $message = _drushsubtree_add_subtree_commit_message($details);

  // Squash commit history of subtree into a single commit?
  $squash_history = (isset($details['squash'])) ? $details['squash'] : FALSE;
  $squash = ($squash_history) ? ' --squash' : '';

  $command = "git subtree pull --prefix={$prefix} {$squash} {$message} {$uri} {$branch}";

  return $command;
}

/**
 * Get prefix (path) to local subtree.
 *
 * @param string $directory
 *   Name of directory where subtree should go.
 *
 * @return string
 *   Path to subtree from top-level of repo to be used for --prefix.
 */
function _drushsubtree_get_prefix($directory) {
  return "projects/{$directory}";
}

/**
 * Get URI for remote git repo.
 *
 * @param array $details
 *   Relevant details for git subtree add command.
 *
 * @return string|bool
 *   Uri for git repo.
 */
function _drushsubtree_get_uri($details) {
  if (!(isset($details['uri']) || !strlen($details['uri']) > 0)) {
    return drush_set_error('drushsubtree', dt("uri is a required subtree parameter for any subtree included here. Please add this to your site's config file, then try again."), 'error');
  }
  else {
    return $details['uri'];
  }
}

/**
 * Get subtree branch from drushsubtree project details included in config file.
 *
 * @param array $details
 *   Relevant details for git subtree add command:
 *
 * @return string|bool
 *   Branch name.
 */
function _drushsubtree_get_branch($details) {
  if (!(isset($details['branch']) || !strlen($details['branch']) > 0)) {
    return drush_set_error('drushsubtree', dt("branchis a required subtree parameter for any subtree included here. Please add this to your site's config file, then try again."), 'error');
  }

  return $details['branch'];
}

/**
 * Get a commit ID ("revision") from a drush make file info.
 *
 * @param string $project_name
 *   Name of project (module, profile, theme, library).
 *
 * @param array $project_info
 *   Project info array from make files.
 *
 * @return string|bool
 *   Project revision (commit) id specified in make file. False if unavailable.
 */
function _drushsubtree_get_id_from_make_info($project_name, $project_info) {
  $id = (isset($project_info['download']['revision'])) ? $project_info['download']['revision'] : FALSE;
  return $id;
}

/**
 * Retrieve list of tags and corresponding commit IDs from remote repository.
 *
 * @param string $project_name
 *   Name of project (module, profile, theme, library).
 *
 * @param array $details
 *   From drushsubtree config.
 *
 * @return array|bool
 *   Commit IDs keyed by tag name. False for failure.
 */
function drushsubtree_list_remote_tags($project_name, $details) {
  // Get a list of commit IDs and corresponding tags. A successful request
  // returns something like this:
  // 516726690a5f3a15ccf8d7ffccd135db4375ad10  refs/tags/7.x-1.0-rc1
  // e214ea5b94f345b66f302d0d4aae232b4128c1e3  refs/tags/7.x-1.0-rc2
  // 8f61c66e5f55e72a35f4a1b8f4eee93a428a03ac  refs/tags/7.x-1.0-rc3
  $command = "git ls-remote --tags {$details['uri']}";
  // Each line of output is stored in $output array.
  // $exit_code is 0 for success, anything else for failure.
  exec($command, $output, $exit_code);

  // Handle failure.
  if ($exit_code !== 0) {
    return drush_set_error('drushsubtree', dt("Request for remote tag list failed: !command", array('!command' => $command)));
  }

  // Parse result.
  $tags = array();
  foreach ($output as $line) {
    // Example line: 8f61c66e5f55e72a35f4a1b8f4eee93a428a03ac  refs/tags/7.x-1.0
    $parts = explode("\t", $line);
    if (count($parts) < 2) {
      // Skip empty lines that sneak in.
      continue;
    }
    $pos = strlen('refs/tags/');
    $tag = substr($parts[1], $pos);
    $id = $parts[0];
    $tags[$tag] = $id;
  }

  return $tags;
}

/**
 * Get tag/version for a project in a make file.
 *
 * @param string $project_name
 *   Name of project (module, profile, theme, library).
 *
 * @param array $project_info
 *   Project info array from make files.
 *
 * @return string
 *   Project version number specified in make file. Empty if unavailable.
 */
function _drushsubtree_get_tag_from_make_info($project_name, $project_info) {
  $tag = '';

  if (isset($project_info['version'])) {
    $tag = $project_info['version'];
  }
  elseif (isset($project_info['download']['tag'])) {
    $tag = $project_info['download']['tag'];
  }

  return $tag;
}

/**
 * Return command for git subtree merge.
 *
 * Note: This terminology is a little confusing. To "checkout" a particular
 * tagged version for a subtree you need to do a git subtree "merge". There is
 * no subtree checkout command.
 *
 * @param string $directory
 *   Name of directory containing subtree.
 *
 * @param array $details
 *   Relevant details for git subtree merge command from config file.
 *
 * @param string $id
 *   Commit id
 *
 * @param string $tag
 *   (Optional) tag from make file, if revision was not explicitly designated.
 *
 * @return string
 *   Git subtree merge command to be executed.
 */
function _drushsubtree_subtree_merge($directory, $details, $id, $tag = '') {
  // Check to see if merges are disabled (e.g. for local development).
  if (isset($details['merge']) && $details['merge'] == FALSE) {
    drush_log(dt('git subtree merge is disabled for !project', array('!project' => $directory)), 'ok');
    return '';
  }

  if ($tag) {
    drush_log(dt('Preparing to merge !subtree_name subtree to id (tag: !tag): !id',
      array('!subtree_name' => $directory, '!id' => $id, '!tag' => $tag)), 'ok');
  }
  else {
    drush_log(dt('Preparing to merge !subtree_name subtree to id: !id',
       array('!subtree_name' => $directory, '!id' => $id)), 'ok');
  }

  // Get params for subtree merge command.
  $prefix = _drushsubtree_get_prefix($directory);
  $message = _drushsubtree_add_subtree_commit_message($details);
  // Build command.
  $command = "git subtree merge --squash --prefix={$prefix} {$message} {$id}";

  return $command;
}

/**
 * Return command to generate symlink to subtree.
 *
 * This command must be run from top-level of repo.
 *
 * @param string $name
 *   Name of project (module, theme, profile) to be replaced with a symlink to a
 *   subtree inside /projects.
 *
 * @param string $path
 *   Path to project in Drupal code base, relative to top-level of site repo.
 *
 * @return string
 *   Shell command for adding symlink.
 */
function _drushsubtree_subtree_add_symlink($name, $path) {
  // Get path to subtree, relative to top-level directory.
  $prefix = _drushsubtree_get_prefix($name);

  // Get source, relative to parent directory inside docroot.
  $count = count(explode('/', $path));
  $source = '';
  for ($i = 0; $i < $count - 1; $i++) {
    $source .= '../';
  };
  // Add prefix to relative source path.
  $source .= $prefix;

  // Parent directory for symlink.
  $pos = strpos($path, $name);
  $parent_directory = substr($path, 0, $pos);

  // Remove the directory. Replace it with a symlink.
  $command = "rm -rf {$path}; cd {$parent_directory}; ln -s {$source} {$name};";

  return $command;
}

/**
 * Commit all additions/deletions.
 *
 * @param string $message
 *   Commit message.
 *
 * @return string
 *   Commit command.
 */
function _drushsubtree_commit($message) {
  if (drush_get_option('no-commit')) {
    drush_log(dt('Skipping git commit.'), 'ok');
    return '';
  }
  // Add any new files added to the repo.
  $command = "git add . ; git commit -am '{$message}';";
  return $command;
}

/**
 * Prep projects directory.
 */
function _drushsubtree_prep_projects_directory() {
  // Before adding/pulling subtrees, make sure parent directory
  // for --prefix exists.
  if (!file_exists('projects')) {
    $success = mkdir('projects', 0777, TRUE);
    if (!$success) {
      return drush_set_error('drushsubtree', dt("Failed creating directory: projects"), 'error');
    }
  }
  elseif (file_exists('projects') && !is_dir('projects')) {
    return drush_set_error('drushsubtree', dt("Please remove the 'projects' file. We need to create a directory with that name for your subtrees."), 'error');
  }

  if ($success) {
    drush_log(dt('A projects directory has been created at the top of your git repo. Git subtrees will be added there.'), 'ok');
  }
}

/**
 * Returns commands to add/update subtrees in a site repo's projects directory.
 *
 * @param array $subtree_name
 *   Config loaded from site make YAML file
 *
 * @param array $details
 *   Config loaded from site make YAML file
 *
 * @param array $project_info
 *   Project info from make file(s)
 *
 * @return array
 *   Commands to be executed via shell_exec().
 */
function _drushsubtree_get_subtree_commands($subtree_name, $details, $project_info) {
  $commands = array();

  // Add git subtree if it doesn't already exist.
  if ($subtree_add = _drushsubtree_subtree_add($subtree_name, $details)) {
    drush_log(dt('Preparing to add subtree: !subtree_name', array('!subtree_name' => $subtree_name)), 'ok');
    $commands[] = $subtree_add;
  }
  // Otherwise, pull in any updates.
  elseif ($subtree_pull = _drushsubtree_subtree_pull($subtree_name, $details)) {
    $commands[] = $subtree_pull;
  }

  // Use git subtree merge to check out a particular version of a project. First
  // get the git commit ID to merge to.
  $id = _drushsubtree_get_id_from_make_info($subtree_name, $project_info);
  if (!$id) {
    // If no commit ID was specified in make file(s), check for tag specified in
    // make file, then try looking corresponding ID using remote list of tags.
    $tag = _drushsubtree_get_tag_from_make_info($subtree_name, $project_info);
    $tags = drushsubtree_list_remote_tags($subtree_name, $details);
    if (!$tag) {
      // Make files do not specify any tag for this project.
      return drush_set_error('drushsubtree', dt("No tag or commit ID available for !name.", array('!name' => $project_name)));
    }
    elseif (!$tags) {
      // Attempt to retrieved tags from remote failed.
      return drush_set_error('drushsubtree', dt("Commit IDs for !name tags could not be retrieved from !remote.\nTo explicitly designate which commit ID to check out for version !tag, you can add this to your makefile (replace abc1234 with a real commit ID):\n\tprojects[!name][download][revision] = abc1234",
        array(
          '!name' => $subtree_name,
          '!remote' => $details['uri'],
          '!tag' => $tag)
      ));
    }
    else {
      // Success!
      $id = $tags[$tag];
    }
  }

  if ($id) {
    if ($subtree_merge = _drushsubtree_subtree_merge($subtree_name, $details, $id, $tag)) {
      $commands[] = $subtree_merge;
    }
  }
  else {
    // @todo Detect latest recommended release on d.o when no version is
    // specified. Consider checking that out to better match standard make file
    // behavior?
    drush_log(dt("No commit ID specified for !project (if a tag was specified in a make file, the cooresponding commit ID could not be retrieved). Your install will run on the tip of whatever branch you checked out. (Subtrees do not fallback to the latest recommended release on drupal.org when no version is specified.)", array('!project' => $subtree_name)), 'warning');
  }

  return $commands;
}

/**
 * Scan for config file. Prompt for selection if more than one found.
 *
 * @return string
 *   File name.
 */
function drushsubtree_get_config_file() {
  $config_files = array();

  // Scan directory for config files like drushsubtree.*.
  exec('pwd', $output, $exit_code);
  $directory = $output[0];
  foreach (drush_scan_directory($directory, '/.*/', array(), 0, FALSE) as $file) {
    $len = strlen('drushsubtree');
    if (substr($file->basename, 0, $len) == 'drushsubtree') {
      $config_files[$file->basename] = $file->basename;
    }
  }

  if (count($config_files) < 1) {
    // No config found. Error.
    drush_return_error(dt('No config file found. See drushsubtree/README.md.'));
  }
  elseif (count($config_files) > 1) {
    // If more than one found, prompt for input.
    $config_file = drush_choice($config_files, dt('Select a config file to use:'));
  }
  else {
    // Only one config file fount.
    $config_file = array_shift($config_files);
  }

  return $config_file;
}

function drush_drushsubtree_checkout($project) {}

function drush_drushsubtree_pull($project) {}

function drush_drushsubtree_push($project) {}

function drush_drushsubtree_add($project) {}
