<?php
use Symfony\Component\Yaml\Parser;
use Symfony\Component\Yaml\Unescaper;
use Symfony\Component\Yaml\Inline;

/**
 * @file
 *   site-make drush command.
 *
 *   You can copy this file to any of the following
 *     1. A .drush folder in your HOME folder.
 *     2. Anywhere in a folder tree below an active module on your site.
 *     3. /usr/share/drush/commands (configurable)
 *     4. In an arbitrary folder specified with the --include option.
 *     5. Drupal's /drush or /sites/all/drush folders.
 */

/**
 * Implementation of hook_drush_command().
 */
function site_make_drush_command() {
  $items = array();

  $items['site-make'] = array(
    'description' => "Wrapper around drush make for (re)building site repos.",
    'arguments' => array(
      'config' => 'path/to/site-make.config.inc',
    ),
    'options' => array(
      'show-info' => array(
        'description' => 'Print $info array from combined make files. (Helpful for development.)',
      ),
      'show-config' => array(
        'description' => 'Print $config array from mysite.config.inc. (Helpful for development.)',
      ),
      'simulate' => array(
        'description' => 'Output commands to be executed for examination, but do not actually execute them.',
      ),
    ),
    'examples' => array(
      'drush site-make mysite.config.inc' => '',
      'drush mks mysite.config.inc --show-info' => '',
    ),
    'aliases' => array('mks'),
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH, // No bootstrap at all.
  );

  $items['site-make-setup-repo'] = array(
  
    // TODO
    // Prompt:
    //   Create symlink-these directory
    //   Create/Symlink sites directory/-ies.
    //   Create/Symlink .htaccess
    //   Create/Symlink robots.txt
    //   Create mysite.config.inc
    //   Symlink build/make files
    // If site is an instance of a distro with tests:
    //   Symlink behat/travis/etc files generated by chris pliakas's drupal-distro
    //   Create testsite.config.inc (if used in build.xml)
    // 

 );

  return $items;
}

/**
 * Implementation of hook_drush_help().
 *
 * @param
 *   A string with the help section (prepend with 'drush:')
 *
 * @return
 *   A string with the help text for your command.
 */
function site_make_drush_help($section) {
  switch ($section) {
    case 'drush:site-make':
      return dt(""); // TODO
  }
}

/**
 * Implementation of drush_hook_COMMAND_validate().
 */
function drush_site_make_validate($config_file) {
  $is_valid = TRUE;

  // TODO Check drush version. Currently, this requires master branch with --no-recurse option.

  // TODO Check ownership. If ant rebuilds, ownership may be funny.

  // TODO This command must be run from top-level of git repo.
  // TODO Confirm we're in a git repo.
  // cd "$(git rev-parse --show-toplevel)"

  // Confirm we have a config file.
  $is_valid = (file_exists($config_file)) ? TRUE : drush_set_error('site_make', dt('Could not find config file, !here'), array('!here' => $config_file));

  // TODO Confirm config points to a make file.
  // TODO Check code base for make files. See if they're all being included in build. If not, notify user. Ask if we should proceed or not.

  // Helper stuff.
  // TODO Check for subtrees. Give user message if not using.
  // TODO Check for commands to shell_exec. Give user message if not using.

  return $is_valid;
}

/**
 * Callback for site-make command.
 *
 * @param string $config_file
 *  path/to/config/file providing $config info
 *
 * @see drush_invoke()
 * @see drush.api.php
 */
function drush_site_make($config_file) {
  // Load config file, providing $conf variable.
  $config = _site_make_get_config($config_file);

  // Get variables from $config;
  $build_file = $config['build_file'];

  // Assemble $info array by loading, parsing and merging make file(s).
  $info = _site_make_get_info($build_file);

  // If requested, output full build info.
  if (drush_get_option('show-info')) {
    drush_print('$info:');
    drush_print(print_r($info));
  }

  // Build up $commands list to be executed...
  $commands = array();

  // If target director already exists, remove it.
  $target = $config['target'];
  if (file_exists($target)) {
    $commands[] = "rm -rf $target";
  }
  
  // Drush make.
  $commands[] = "drush make {$build_file} {$target} --no-recursion --no-gitinfofile";

  // Set up subtrees.
  foreach ($config['subtrees'] as $subtree_name => $details) {
    // Add git subtree if it doesn't already exist.
    if($add_subtree =  _site_make_subtree_add($subtree_name, $details)) {
      $commands[] = $add_subtree;
    }

    // Pull in newest updates from subtree's external repo.
    $commands[] = _site_make_subtree_pull($subtree_name, $details);

    // Checkout tagged version of project specified in make file.
    if ($tag = _site_make_get_tag($subtree_name, $info)) {
      $commands[] = _site_make_subtree_merge($subtree_name, $tag);
    }
    else {
      // @todo Detect latest recommended release on d.o when no version is specified. Consider checking that out to better match standard make file behavior?
      drush_log(dt("No version specified for !project in makefile(s). Your install will run on the tip of whatever branch you checked out. (Subtrees do not fallback to the latest recommended release on drupal.org when no version is specified.)", array('!project' => $subtree_name)), 'warning');
    }

    // Remove files checked out by drush. (To be replaced with a symlink.)
    // Add symlink pointing to your local subtree.
    $commands[] = _site_make_subtree_add_symlink($subtree_name, $path);
  }

  // Add custom commands.
  foreach ($config['commands'] as $command) {
    $commands[] = $command;
  }

  // Execute commands.
  foreach ($commands as $command) {
    drush_shell_exec($command);
  }
}

/**
 * Load config from config file by calling site_make_config().
 *
 * Helpful tip for developers: You can convert a PHP array to YAML via drush
 * like this. If you know the $config array you want, but you're not sure how to
 * form at it, build the array, then run it through this function:
 *
 *   drush_print(drush_format($config, NULL, 'yaml'));
 *
 * @return array $config
 */
function _site_make_get_config($config_file) {
  if (!class_exists('Symfony\Component\Yaml')) {
    // For Drush PSR-0 and Composer information, see http://drupal.org/node/1316322.
    $path = DRUSH_BASE_PATH . '/lib/Yaml-' . DRUSH_YAML_VERSION;
    require_once "$path/Yaml.php";
    require_once "$path/Parser.php";
    require_once "$path/Unescaper.php";
    require_once "$path/Inline.php";
  }
  $parser = new Parser();
  $config = $parser->parse(file_get_contents('mysite.config.yml'));

  // If requested, output loaded config
  if (drush_get_option('show-config', FALSE)) {
    drush_print('$config:');
    drush_print(drush_format($config, NULL, 'yaml'));
  }

  return $config;
}

/**
 * Parse make/info files.
 *
 * @return array $info
 *  Assemble $info array by loading, parsing and merging make file(s).
 */
function _site_make_get_info($file) {
  // Load $info from info/make file if it exists.
  if (file_exists($file)) {
    $info = make_parse_info_file($file);  
  }
  else {
    return drush_set_error('site_make', dt('Make file does not exist: !here.', array('!here' => $file)));
  }

  // Check for included make files. If they exist, recurse.
  $merge_info = array();
  if (isset($info['includes'])) {
    foreach ($info['includes'] as $include) {
      $more_info = _site_make_get_info($include);
      $merge_info = array_merge_recursive_distinct($merge_info, $more_info);
    }
  }

  $info = array_merge_recursive_distinct($info, $merge_info);

  return $info;
}

/**
 * http://danielsmedegaardbuus.dk/2009-03-19/phps-array_merge_recursive-as-it-should-be/
 */
function &array_merge_recursive_distinct(array &$array1, &$array2 = null)
{
  $merged = $array1;
 
  if (is_array($array2))
    foreach ($array2 as $key => $val)
      if (is_array($array2[$key]))
        $merged[$key] = is_array($merged[$key]) ? array_merge_recursive_distinct($merged[$key], $array2[$key]) : $array2[$key];
      else
        $merged[$key] = $val;
 
  return $merged;
}

/**
 * Generate git subtree add command to be run from top-level of repo.
 *
 * @param string directory
 *   Directory name where subtree should live
 *
 * @param array $details
 *   Relevant details for git subtree add command:
 *    - uri
 *    - branch
 *    - squash
 *    - message
 *
 * @return string | bool
 *   Return command to be executed. False for don't do anything.
 */
function _site_make_subtree_add($directory, $details) {
  $prefix = _site_make_get_prefix($directory);

  if (!file_exists($prefix)) {
    // Subtree has already been created. Or there's a directory in our way. Skip this step.
    drush_log(dt("This directory already exists: !prefix", $prefix), array('!prefix' => $prefix), 'notice');
    drush_log(dt("Git subtree add command will be skipped. If !prefix is not a subtree, remove this directory and re-run the site-make command.", $prefix), array('!prefix' => $prefix), 'warning');
    // We're done. Return.
    return FALSE;
  }

  // Make sure we have minimum required $details.
  $uri = _site_make_get_uri($details);
  $branch =  _site_make_get_branch($details);
  if (!$uri || !$branch) {
    // We're done. Return.
    return FALSE;
  }

  // Squash commit history of subtree into a single commit?
  $squash_history = (isset($details['squash'])) ? $details['squash'] : FALSE;
  $squash = ($squash_history) ? ' --squash' : '';

  // Add custom commit message?
  $add_custom_message = (isset($details['message'])) ? $details['message'] : FALSE;
  $message = ($add_custom_message) ? " --message='{$details['message']}'" : '';

  // Build the command to add subtree for the first time.
  $command = "git subtree add --prefix={$prefix} {$squash} {$message} $uri $branch";

  return $command;  
}

/**
 * Generate git subtree pull command to be run from top-level of repo.
 *
 * @param string directory
 *   Directory name where subtree should live
 *
 * @param array $details
 *   Relevant details for git subtree add command:
 *    - uri
 *    - branch
 *    - squash
 *    - message
 *
 * @return string | bool
 *   Return command to be executed. False for don't do anything.
 */
function _site_make_subtree_pull($directory, $details) {
  $prefix = _site_make_get_prefix($directory);
  $uri = _site_make_get_uri($details);
  $branch =  _site_make_get_branch($details);

  $command = "git subtree pull --prefix={$prefix} {$uri} {$branch}";

  return $command;
}

/**
 * @param string $directory
 *   Name of directory where subtree should go.
 *
 * @return string $prefix
 *   Path to subtree from top-level of repo.
 */
function _site_make_get_prefix($directory) {
  return "projects/{$directory}";
}

/**
 * @param array $details
 *   Relevant details for git subtree add command:
 *
 * @return string | bool
 */
function _site_make_get_uri($details) {
  if (!(isset($details['uri']) || !strlen($details['uri']) > 0)) {
    return drush_set_error('site_make', dt("uri is a required subtree parameter for any subtree included here. Please add this to your site's config file, then try again."), 'error');
  }
  else {
    return $details['uri'];
  }
}

/**
 * @param array $details
 *   Relevant details for git subtree add command:
 *
 * @return string | bool
 */
function _site_make_get_branch($details) {
  if (!(isset($details['branch']) || !strlen($details['branch']) > 0)) {
    return drush_set_error('site_make', dt("branchis a required subtree parameter for any subtree included here. Please add this to your site's config file, then try again."), 'error');
  }
  else {
    return $details['branch'];
  }
}

/**
 * @param string $project_name
 *  Name of project (module, profile, theme, library).
 *
 * @param array $info
 *  Full project info array from make files.
 *
 * @return float | bool
 *  Project version number specified in make file. False if unavailable.
 */
function _site_make_get_tag($project_name, $info) {
  foreach ($info['projects'] as $name => $details) {
    if ($name == $project_name) {
      $has_version = (isset($details['version'])) ? TRUE : FALSE;
      $tag = ($has_version) ? $details['version'] : FALSE;
    }
  }
  return $tag; 
}

/**
 * Return command for git subtree merge.
 *
 * Note: This terminology is a little confusing. To "checkout" a particular
 * tagged version for a subtree you need to do a git subtree "merge". There is
 * no subtree checkout command. 
 *
 * @param string $directory
 *
 * @param float $tag
 *
 * @return string
 *   Git subtree merge command to be executed.
 */
function _site_make_subtree_merge($directory, $tag) {
  $prefix = _site_make_get_prefix($directory);
  $command = "git subtree merge --prefix={$prefix} {$tag}";
  return $command;
}

/**
 * Return command to generate symlink to subtree.
 *
 * This command must be run from top-level of repo.
 *
 * @param string $name
 *
 * @param string $path
 */
function _site_make_subtree_add_symlink($name, $path) {
  // Make sure $path exists.
  if (!file_exists($path)) {
    return drush_set_error('site_make', dt('This directory does not exist: !path'), array('!path' => $path));
  }

  // Get source, relative to parent directory inside docroot.
  $count = count(explode('/', $path));
  $source = '';
  for ($i = 0; $i < $count; $i++) { 
    $source .= '../'; 
  };
  // Add prefix to relative source path.
  $source .= _site_make_get_prefix($name);

  // Remove the directory. Replace it with a symlink.
  $command = "rm -rf {$path}; ln -s {$source} {$path};";

  return $command;  
}
